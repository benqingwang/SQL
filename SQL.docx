基础知识	
【评估顺序】 FROM WHERE GROUP BY HAVING SELECT  Order by
【Foreign key】是一种cross reference，link到另一个table的primary key.Foreign key可以是一个或者多个column
提高效率的思路[1] 先排除没有用的null再做join之类的操作 [2]不要无用的alias会提高速度
我常犯的语法错误 [1] 多个from的table，然后我忘记用逗号分开 [2] Nested select的时候，我select的column不全
SQL Server Shortcut：【Execution】 F5 【New Query】Ctrl+N【在SQL server filter table】 右键table -> 选filters -> filter seetings ->录入你的条件  
数据类型	【String】 SQL里面的string用单引号，比如 ‘boring’
【ENUM】是一种数据类型，必须是one of a set of predefined constants. 比如东南四倍四个方向，一周7天这种
Database语法	【创建DB 】CREATE DATABASE QW;
【创建Schema 】Schema是在Database的Security下面USE QW; GO || CREATE schema dogs;
【创建table】除了要有table name你必须要定义column和column的data type
CREATE TABLE        cats (CatID int, CatName varchar(255), Age tinyint,);
【在特定DB建立】如果不说明，新建table自动在master database里。如果想建立table在QW database，需要先USE: USE QW; GO || CREATE TABLE cats (CatID int,CatName varchar(255),Age tinyint,);	Schema长这样
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| user_id     | int     |
| name        | varchar |
+-------------+---------+
Select
Where
Join
Union
Order
Group
Having	【Select】【Join】【AS使用Alias】【Where】SELECT a.name AS names || FROM  a  || LEFT JOIN b  ||ON a.id=b. Id || WHERE b.id IS NULL
	【Select Distinct】SELECT DISTINCT Salary FROM Employee
	【其他Join】INNER JOIN, FULL OUTER JOIN【Inner Join Without Join 利用等号】SELECT  * ||   FROM   a, b  ||  WHERE   a.x=b.y
	【Union】SELECT employee_id FROM Employees  || UNION || SELECT employee_id FROM Salaries
	【用order来排序】 SELECTSalary  FROM Employee  ORDER BY Salary DESC, ID ASC
	【Group by & Having】经常用于寻找某个category的max或者duplicate等：用Group by，Select后面的column必须是：[a] Group by 的对象，比如下面的Email, or [b] 可以Aggregate的东西SELECT Email  || FROM Person  || GROUP BY Email || Having  COUNT(Email)>1
或者 SELECT a, COUNT(a) AS count_a ||FROM table ||WHERE …. ||GROUP BY a
条件	【CASE…WHEN…WHEN…ELSE…END】SELECT || CASE  || WHEN id%2=0 THEN id-1 || ELSE id+1 || END AS id || FROM  seat
数学和逻辑	【IS NULL】WHERE   referee_id IS NULL
【ISNULL( )】类似于IFERROR: Select ISNULL(field, 100) 或者Select isnull (result of a select, null) 或者Select isnull (result of a select, 100)
	【COUNT( --- )】语法： Count(column), Count (*)【COUNT (DISTINCT  --- )】SELECT a, COUNT(DISTINCT b) FROM table GROUP BY a
【SUM】这类的函数里面还可以有运算的，比如SELECT a, SUM(b-c) FROM tbl GROUP BY a
	【求余数】employee_id % 2 = 1 判断employee_id是奇偶数
【AND/OR】WHERE   area>3 OR population >25
【NOT】【Like】【%】name NOT LIKE 'M%', %可以代表空。	+----+-----+-----+-----+
| Id | Num | LAG | LEAD|
+----+-----+-----+-----+
| 1  | 10  |NULL | 20  |
| 2  | 20  | 10  | 30  |
| 3  | 30  | 20  | 40  |
| 4  | 40  | 30  | 50  |
| 5  | 50  | 40  |NULL |
+----+-----+-----+-----+
	【计算日期：dateadd(day,1,date )】SELECT dateadd(day,1, date) as new_date, value FROM tbl
【日期期间】WHERE a.activity_date <='2019-07-27' AND a.activity_date > dateadd(day,-30,'2019-07-27')
【某年DATEPART( )】where datepart(YYYY, 某time_stamp) = 2020	
	【LAG()和LEAD()】LAG(Num) OVER(ORDER BY id) ：LAG求上一个LEAD (Num) OVER(ORDER BY id )：Lead是求下一个
	【MAX/MIN】SELECT MAX(p_id)FROM Tree
【SELECT MAX对应的其他column 】select a, max(b) as last_b from tbl group by a 这里关键是一定要用Group by. 
【增加MAX信息】SELECT a, MAX(b) OVER (PARTITION BY a) AS last_b FROM tbl
【用MAX MIN发现在一个值域内的item】
WITH a AS (SELECT  product_id, MAX(sale_date) AS last, MIN(sale_date) AS first FROM Sales  GROUP BY product_id)
SELECT a.product_id, Product.product_name FROM a LEFT JOIN Product ON Product.product_id=a.product_id
WHERE a.last<='2019-03-31' AND a.first>='2019-01-01'
操作String	【STRING_AGG… WITHIN GROUP (ORDER BY …)】把query出来的结果作为一个string输出
SELECT  sell_date, STRING_AGG(a.product, ',') WITHIN GROUP (ORDER BY product) FROM  Activities GROUP BY a.sell_date
【LEFT, RIGHT, LEN, UPPER LOWER】
SELECT user_id,UPPER(LEFT(name, 1))+LOWER(RIGHT(name, LEN(name)-1)) as name FROM Users ORDER BY user_id
改变一个Table	【根据条件update table用where】UPDATE   QW.dbo.favo_fish || SET  fish='capri' ||WHERE  id=4
	【根据多个条件update table 就要用CASE】UPDATE  Salary ||SET sex= CASE WHEN sex='m' THEN 'f' ELSE 'm' END
	【Delete (remove duplicates保留idx最小的)】【这里我们用到一个技巧是给同一个table两个不同的代号，方便做对比】
DELETE  p1         ||  FROM person p1, person p2               || WHERE 	p1.email=p2.email AND p1.id>p2.id
【找到duplicate】SELECT DISTINCT a.email AS Email || FROM Person a, Person b || WHERE a.id>b.id AND a.email=b.email
Subquery	【用subquery得一个数】SELECT || CASE || WHEN id+1>(select count(*) as counts from seat) THEN id || ELSE id+1 ||END AS id || FROM    seat 
【如果subquery在from里面， select要refer to column不是table】SELECT || CASE ||  WHEN id+1>counts THEN id || ELSE id+1 || END AS id || FROM   seat, (select count(*) as counts from seat) temp
	【用subquery得list】Select || CASE || WHEN id%2=1 AND id+1 not in (select id from seat)    THEN id || ELSE id+1 ||END AS id ||FROM seat
	【在where里面使用subquery】相当于把select from中的变量当作一个常量在where中使用。这个时候通常有count(), sum()之类的
SELECT DISTINCT  (a.num) as ConsecutiveNums|| FROM logs a ||
WHERE     3= (Select count (distinct b.id) as value from logs b where b.id>=a.id AND b.id<=a.id+2 AND b.num=a.num)
	Subquery还可以先用with .. as ()定义。我觉得这样更清晰明确
with a as   (SELECT      FROM       WHERE    GROUP BY)
SELECT    tbl.x, a.y FROM tbl LEFT JOIN  a  ON  a.z=tbl.z
排序	【DENSE RANK() vs Rank()】Dense Rank：的特点是排序中间没有hole，比如你看下面的结果，尽管Jim和Max2个并列第一，Henry的排序是2而不是3。Rank：中间有hole，Henry的排序这里是3。
	SELECT *,DENSE_RANK() OVER (ORDER BY Salary DESC) AS Rank FROM  Employee
SELECT *,RANK()                    OVER (ORDER BY Salary DESC) AS Rank FROM Employee
		+----+-------+--------+---------+
| Id | Name  | Salary | Dense   |
+----+-------+--------+---------+
| 2  | Jim   | 90000  | 1       |
| 5  | Max   | 90000  | 1       |
| 3  | Henry | 80000  | 2       |
| 1  | Joe   | 70000  | 3       |
| 4  | Sam   | 60000  | 4       |
+----+-------+--------+---------+	+----+-------+--------+------+
| Id | Name  | Salary | Rank |
+----+-------+--------+------+
| 2  | Jim   | 90000  | 1    |
| 5  | Max   | 90000  | 1    |
| 3  | Henry | 80000  | 3    |
| 1  | Joe   | 70000  | 4    |
| 4  | Sam   | 60000  | 5    |
+----+-------+--------+------+
进阶用法-Partition By
	+----+-------+--------+-----+
| id | name  | salary | dId |
+----+-------+--------+-----+
| 1  | Joe   | 70000  | 1   |
| 2  | Jim   | 90000  | 1   |
| 3  | Henry | 80000  | 2   |
| 4  | Sam   | 60000  | 2   |
| 5  | Max   | 90000  | 1   |
+----+-------+--------+-----+	
Patrition by相当于打开一个小window得到一个数字然后返回给我们
SELECT *, DENSE_RANK() OVER (PARTITION BY dId ORDER BY Salary DESC) AS Rank
FROM    Employee	

+----+-------+--------+-----+-----+
| id | name  | salary | dId |Rank |
+----+-------+--------+-----+-----+
| 2  | Jim   | 90000  | 1   | 1   |
| 5  | Max   | 90000  | 1   | 1   |
| 1  | Joe   | 70000  | 1   | 3   |
| 3  | Henry | 80000  | 2   | 1   |
| 4  | Sam   | 60000  | 2   | 2   |
+----+-------+--------+-----+-----+

Partition单用: SELECT name, MIN(order) OVER (PARTITION BY name) AS min_order FROM tbl
注意partition是增加信息(min值)，并没有选出min的作用，所以tbl还是原来的行数。

如果你的目的是选出每个name对应最小的order 应该用:
SELECT name, MIN(order) AS min_order FROM tbl GROUP BY name	+----+-------+------+-----------+
| id | name  | order| min_order |
+----+-------+------+-----------+
| 1  | Jim   | 900  | 200       |
| 1  | Jim   | 200  | 200       |
| 2  | Joe   | 700  | 700       |
| 3  | Henry | 800  | 800       |
+----+-------+------+-----------+
进阶用法-SQL自定义函数	【1】CREATE FUNCTION  是statement
【2】getNthHighestSalary( ) 是函数名字
【3】@N INT是代表函数自变量得是一个整数
【4】RETURNS INT代表函数输出也是整数
【5】BEGIN…RETURN ()…END就是函数定义	CREATE FUNCTION getNthHighestSalary(@N INT) RETURNS INT AS
BEGIN 
RETURN  
(SELECT field FROM table Where field=@N)
END
Nested SQL	SELECT a.employee_id
FROM (SELECT employee_id FROM Employees UNION SELECT employee_id FROM Salaries) a
WHERE  a.employee_id NOT IN (SELECT Employees.employee_id FROM Employees INNER JOIN Salaries ON Employees.employee_id=Salaries.employee_id)	利用(Select….) a 作为data source
Unpivot的方法
	Products table:
+--------+--------+-------+-------+
|product_id| store1|store2|store3 |
+--------+--------+-------+-------+
| 0      | 95     | 100   |105    |
| 1      | 70     | null  |80     |
+--------+--------+-------+-------+
Output:
+------------+--------+-------+
| product_id | store  | price |
+------------+--------+-------+
| 0          | store1 | 95    |
| 0          | store2 | 100   |
| 0          | store3 | 105   |
| 1          | store1 | 70    |
| 1          | store3 | 80    |
+------------+--------+-------+	
【方法1: CROSS】
SELECT product_id, store, price
FROM Products
CROSS APPLY
(VALUES ('store1', store1),('store2', store2), ('store2', store3)) c (store, price)
WHERE price IS NOT NUll;

【方法2: UNION】
SELECT product_id,'store1' AS store, store1 AS price FROM Products  UNION
SELECT product_id,'store2' AS store, store2 AS price FROM Products UNION
SELECT product_id,'store3' AS store, store3 AS price FROM Products
